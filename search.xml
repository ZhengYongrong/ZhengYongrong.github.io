<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker学习笔记</title>
      <link href="/2019/12/21/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/12/21/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。<br><img src="https://img-blog.csdnimg.cn/2019120709145317.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191207091505219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM0MjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用<br><img src="https://img-blog.csdnimg.cn/2019120709154056.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM0MjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="3、安装Docker"><a href="#3、安装Docker" class="headerlink" title="3、安装Docker"></a>3、安装Docker</h2><h4 id="1）、安装linux虚拟机（或者使用阿里云服务器）"><a href="#1）、安装linux虚拟机（或者使用阿里云服务器）" class="headerlink" title="1）、安装linux虚拟机（或者使用阿里云服务器）"></a>1）、安装linux虚拟机（或者使用阿里云服务器）</h4><pre><code>1）、VMWare、VirtualBox（安装）；2）、导入虚拟机文件；3）、双击启动linux虚拟机;使用  root/ 123456登陆4）、使用客户端连接linux服务器进行命令操作；5）、设置虚拟机网络；    桥接网络===选好网卡====接入网线；6）、设置好网络以后使用命令重启虚拟机的网络</code></pre><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network restart<br></code></pre></td></tr></table></figure><pre><code>7）、查看linux的ip地址</code></pre><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br></code></pre></td></tr></table></figure><pre><code>8）、使用客户端连接linux；</code></pre><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>一、<strong>配置阿里云yum源（提高docker软件下载速度）：</strong> <a href="https://www.cnblogs.com/operationhome/p/11094493.html" target="_blank" rel="noopener">参考连接</a><br>1、备份</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br></code></pre></td></tr></table></figure><p>2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/<br>CentOS 7</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><p>或者</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><p>3、生成新的缓存</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clean all<br>yum makecache<br>yum update<br></code></pre></td></tr></table></figure><p>二、安装docker步骤：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、检查内核版本，必须是3.10及以上<br>uname -r<br><br>2、使用 root 权限登录 Centos。确保 yum 包更新到最新。<br>yum update<br><br>3、卸载旧版本(如果安装过旧版本的话)<br><span class="hljs-meta">$</span><span class="bash"> yum remove docker  docker-common docker-selinux docker-engine</span><br><br>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的<br><span class="hljs-meta">$</span><span class="bash"> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><br>5、设置yum源<br><span class="hljs-meta">$</span><span class="bash"> sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><br>6、可以查看所有仓库中所有docker版本，并选择特定版本安装<br><span class="hljs-meta">$</span><span class="bash"> yum list docker-ce --showduplicates | sort -r</span><br><br>7、安装docker<br><span class="hljs-meta">$</span><span class="bash">  yum install docker-ce-17.12.0.ce <span class="hljs-comment">#由于repo中默认只开启stable仓库，这里安装的是稳定版17.12.0</span></span><br><br>8、启动docker<br>[root@localhost ~] systemctl start docker<br>[root@localhost ~] docker -v<br>Docker version 1.12.6, build 3e8e77d/1.12.6<br><br>9、开机启动docker<br>[root@localhost ~] systemctl enable docker<br>Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.<br><br>10、停止docker<br>systemctl stop docker<br></code></pre></td></tr></table></figure><h2 id="4、Docker常用命令-amp-操作"><a href="#4、Docker常用命令-amp-操作" class="headerlink" title="4、Docker常用命令&amp;操作"></a>4、Docker常用命令&amp;操作</h2><h3 id="1）、镜像操作"><a href="#1）、镜像操作" class="headerlink" title="1）、镜像操作"></a>1）、镜像操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><strong>镜像查找：</strong> <a href="https://hub.docker.com/（包含具体镜像的操作命令）" target="_blank" rel="noopener">https://hub.docker.com/（包含具体镜像的操作命令）</a><br><strong>docker改国内官方镜像(提升镜像pull速度):</strong><br>编辑文件/etc/docker/daemon.json，没有就新建。加入以下项目</p><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">"registry-mirrors"</span>: [<span class="hljs-string">"https://registry.docker-cn.com"</span>,<span class="hljs-string">"http://hub-mirror.c.163.com"</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>本身daemon.json文件已经有项目，就额外增加registry-mirrors项</p><p>重启docker daemon</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="2）、容器操作"><a href="#2）、容器操作" class="headerlink" title="2）、容器操作"></a>2）、容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、搜索镜像<br>[root@localhost ~] docker search tomcat<br>2、拉取镜像<br>[root@localhost ~] docker pull tomcat<br>3、根据镜像启动容器<br>docker run --name mytomcat -d tomcat:latest<br>4、docker ps  <br>查看运行中的容器<br>5、 停止运行中的容器<br>docker stop  容器的id<br>6、查看所有的容器（包括没有运行的）<br>docker ps -a<br>7、启动容器<br>docker start 容器id<br>8、删除一个容器<br> docker rm 容器id<br>9、启动一个做了端口映射的tomcat<br>[root@localhost ~]# docker run -d -p 8888:8080 tomcat<br>-d：后台运行<br>-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口<br><br>10、为了演示简单关闭了linux的防火墙<br>service firewalld status ；查看防火墙状态<br>service firewalld stop：关闭防火墙<br>11、查看容器的日志<br>docker logs container-name/container-id<br></code></pre></td></tr></table></figure><p><strong>更多命令参看</strong><br><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/docker/</a><br>可以参考每一个镜像的文档</p><h3 id="3）、安装MySQL示例"><a href="#3）、安装MySQL示例" class="headerlink" title="3）、安装MySQL示例"></a>3）、安装MySQL示例</h3><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.7<br></code></pre></td></tr></table></figure><p>正确的启动：做了端口映射</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql<br>ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES<br>ad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02<br></code></pre></td></tr></table></figure><p>几个其他的高级操作</p><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker <span class="hljs-builtin-name">run</span> --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag<br>把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面<br>改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）<br><br>docker <span class="hljs-builtin-name">run</span> --name some-mysql -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag <span class="hljs-attribute">--character-set-server</span>=utf8mb4 <span class="hljs-attribute">--collation-server</span>=utf8mb4_unicode_ci<br>指定mysql的一些配置参数<br></code></pre></td></tr></table></figure><p><strong>docker安装mysql后外部无法访问，解决办法：</strong></p><ol><li>记得开启阿里云相应的端口号</li><li>修改权限<figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">使用bash窗口<br>docker exec -it mysqlDB bash<br><br>登陆mysql<br>mysql -uroot -p123456;<br><br>修改权限<br><span class="hljs-meta">&gt;</span><span class="bash"> use mysql;</span><br><span class="hljs-meta">&gt;</span><span class="bash"> update user <span class="hljs-built_in">set</span> authentication_string = password(<span class="hljs-string">'123456'</span>) <span class="hljs-built_in">where</span> user = <span class="hljs-string">'root'</span>;</span><br><span class="hljs-meta">&gt;</span><span class="bash"> grant all privileges on *.* to <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> identified by <span class="hljs-string">'123456'</span> with grant option;</span><br><span class="hljs-meta">&gt;</span><span class="bash"> flush privileges;</span><br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">exit</span>;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4）、安装redis"><a href="#4）、安装redis" class="headerlink" title="4）、安装redis"></a>4）、安装redis</h3><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis:5.0.7<br></code></pre></td></tr></table></figure><p>正确的启动：做了端口映射</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~] docker run -d -p 6381:6379 --name myredis  redis:5.0.7 --requirepass "123456"<br><span class="hljs-meta">#</span><span class="bash"> --requirepass <span class="hljs-string">"123456"</span> 设置密码</span><br><span class="hljs-meta">#</span><span class="bash"> -p 6381:6379：映射容器服务的 6379 端口到宿主机的 681 端口。外部可以直接通过宿主机ip:6381 访问到 Redis 的服务</span><br>[root@localhost ~] docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES<br>dff3d4e7ef6b        redis:5.0.7         "docker-entrypoint.s…"   16 minutes ago      Up 16 minutes       0.0.0.0:6381-&gt;6379/tcp              myredis<br>[root@localhost ~] docker exec -it myredis bash <br><span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it xxx bash 这个命令是表示进入容器的，xxx是服务名称也可以是容器的id</span><br></code></pre></td></tr></table></figure><p>几个其他的高级操作</p><figure class="hljs highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># docker run -<span class="hljs-keyword">p</span> <span class="hljs-number">6382</span>:<span class="hljs-number">6379</span> --name myredis -v $PWD/redis.<span class="hljs-keyword">conf</span>:/etc/redis/redis.<span class="hljs-keyword">conf</span> -v $PWD/dat<span class="hljs-variable">a:</span>/data -d <span class="hljs-keyword">redi</span><span class="hljs-variable">s:5</span>.<span class="hljs-number">0.7</span> redis-server /etc/redis/redis.<span class="hljs-keyword">conf</span> --appendonly yes<br>　　命令说明：<br>　　--name myredis : 指定容器名称，这个最好加上，不然在看docker进程的时候会很尴尬。<br>　　-<span class="hljs-keyword">p</span> <span class="hljs-number">6699</span>:<span class="hljs-number">6379</span> ： 端口映射，默认redis启动的是<span class="hljs-number">6379</span>，至于外部端口，随便玩吧，不冲突就行。<br>　　-v $PWD/redis.<span class="hljs-keyword">conf</span>:/etc/redis/redis.<span class="hljs-keyword">conf</span> ： 将主机中当前目录下的redis.<span class="hljs-keyword">conf</span>配置文件映射。<br>　　-v $PWD/dat<span class="hljs-variable">a:</span>/data -d <span class="hljs-keyword">redi</span><span class="hljs-variable">s:3</span>.<span class="hljs-number">2</span> ： 将主机中当前目录下的data挂载到容器的/data<br>　　--redis-server --appendonly yes :在容器执行redis-server启动命令，并打开redis持久化配置\<br></code></pre></td></tr></table></figure><p><strong>docker安装redis后外部无法访问，解决办法：</strong> 记得开启阿里云相应的端口号.</p><h3 id="5）、安装Elasticsearch"><a href="#5）、安装Elasticsearch" class="headerlink" title="5）、安装Elasticsearch"></a>5）、安装Elasticsearch</h3><p><a href="https://blog.csdn.net/qq_32101993/article/details/100021002" target="_blank" rel="noopener">参考文章：https://blog.csdn.net/qq_32101993/article/details/100021002</a><br>拉取镜像：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull elasticsearch:tag(6.8.5)<br></code></pre></td></tr></table></figure><p>启动：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~] docker run -d  -e  ES_JAVA_OPTS="-Xms256m -Xmx256m"   -p 9200:9200   -p 9300:9300  --name ES01  elasticsearch:版本号(如果是latest则不写) <br>[root@localhost ~] docker ps<br><span class="hljs-meta">#</span><span class="bash"> 查看是否成功</span><br>CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                                            NAMES<br>c3f23945d1ed        elasticsearch:6.8.5   "/usr/local/bin/dock…"   6 minutes ago       Up 53 seconds       0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   ES01<br></code></pre></td></tr></table></figure><p><strong>此时已经可以正常外部访问网址：域名:端口号</strong></p><p>配置跨域：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.首先进入容器<br>docker exec -it ES01 /bin/bash<br>2.安装vim<br>yum -y install vim*<br>3.编辑/config/elasticsearch.ym<br>vim elasticsearch.yml <br>4.添加内容<br>cluster.name: "qfcwx-cluster"   <br>network.host: 0.0.0.0<br>http.cors.enabled: true<br>http.cors.allow-origin: "*"<br>5.exit<br>6.重启<br>docker restart ES01(容器id或者name)<br></code></pre></td></tr></table></figure><ol><li>cluster.name：自定义集群名称。</li><li>network.host：当前es节点绑定的ip地址，默认127.0.0.1，如果需要开放对外访问这个属性必须设置。</li><li>http.cors.enabled：是否支持跨域，默认为false。</li><li>http.cors.allow-origin：当设置允许跨域，默认为*，表示支持所有域名，如果我们只是允许某些网站能访问，那么可以使用正则表达式。</li></ol><p><img src="https://img-blog.csdnimg.cn/201912071557173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM0MjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>访问截图：</p><p><img src="https://img-blog.csdnimg.cn/20191207155655168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM0MjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5）、安装rabbitMQ"><a href="#5）、安装rabbitMQ" class="headerlink" title="5）、安装rabbitMQ"></a>5）、安装rabbitMQ</h3><p><a href="https://www.cnblogs.com/yufeng218/p/9452621.html" target="_blank" rel="noopener">参考文章：https://www.cnblogs.com/yufeng218/p/9452621.html</a><br>拉取镜像：选择带有<strong>mangement</strong>的版本（<strong>包含web管理页面</strong>）</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull rabbitmq:management<br></code></pre></td></tr></table></figure><p>启动：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~] docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -v `pwd`/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin 6bd1749b8197<br>[root@izlnxqoeytyh4fz ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                         NAMES<br>c6575d289410        6bd1749b8197        "docker-entrypoint.s…"   6 seconds ago       Up 4 seconds        4369/tcp, 5671/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp, 0.0.0.0:15673-&gt;5672/tcp   rabbitmq<br></code></pre></td></tr></table></figure><ul><li>-v 映射目录或文件；</li><li>–hostname  主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；</li><li>-e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）</li></ul><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment"># 进入控制台</span><br>docker exec -<span class="hljs-keyword">it</span> rabbitmq  /bin/bash<br></code></pre></td></tr></table></figure><p><strong>此时已经可以正常外部访问网址：域名:端口号</strong></p><p>访问截图：<br><img src="https://img-blog.csdnimg.cn/20191218105031534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM0MjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁与悲观锁</title>
      <link href="/2019/08/28/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2019/08/28/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="何谓悲观锁与乐观锁"><a href="#何谓悲观锁与乐观锁" class="headerlink" title="何谓悲观锁与乐观锁"></a>何谓悲观锁与乐观锁</h3><p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h4 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h4><p>乐观锁一般会使用版本号机制或CAS算法实现。</p><ol><li>版本号机制<br>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ol><p>举一个简单的例子：<br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><p>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。<br>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。<br>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。<br>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 当前最后更新的version与操作员第一次的版本号相等 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><ol start="2"><li>CAS算法<br>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</li></ol><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B<blockquote><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么使用List list = new ArrayList()</title>
      <link href="/2019/07/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFList-list-new-ArrayList%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8-ArrayList-list-new-ArrayList/"/>
      <url>/2019/07/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFList-list-new-ArrayList%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8-ArrayList-list-new-ArrayList/</url>
      
        <content type="html"><![CDATA[<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li><p>List是一个接口，而ArrayList 是一个类，ArrayList 继承并实现了List。</p></li><li><p>List list = new  ArrayList();这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个List对象了，有些ArrayList有但是 List没有的属性和方法，它就不能再用了。</p></li><li><p>而ArrayList list=new  ArrayList();创建一对象则保留了ArrayList的所有属性。</p></li></ul><h3 id="面向接口编程思想"><a href="#面向接口编程思想" class="headerlink" title="面向接口编程思想"></a>面向接口编程思想</h3><p> 首先，面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</p><figure class="hljs highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// 1.这样你就只能调用List接口里面定义好的方法，而不能使用你自己在ArrayList扩展的方法。</span><br>     <span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();<br>      <br><span class="hljs-comment">// 2.这样你可以使用自己在ArrayList类上扩展的方法</span><br>    ArrayList <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();<br><span class="hljs-comment">// 接口就是定义了一些行为，它要求你应该做什么。</span><br><span class="hljs-comment">// 假如你采用了面向接口编程方式，也就是第一种方式：List list = new ArrayList();</span><br><span class="hljs-comment">// 就能通过接口很大限度上规范开发人员的实现规则，因为你现在只能调用接口的方法。</span><br></code></pre></td></tr></table></figure><h4 id="为什么一般都使用-List-list-new-ArrayList-而不用-ArrayList-alist-new-ArrayList-呢？"><a href="#为什么一般都使用-List-list-new-ArrayList-而不用-ArrayList-alist-new-ArrayList-呢？" class="headerlink" title="为什么一般都使用 List list = new ArrayList() ,而不用 ArrayList alist = new ArrayList()呢？"></a>为什么一般都使用 List list = new ArrayList() ,而不用 ArrayList alist = new ArrayList()呢？</h4><blockquote><p>如果没有特别需求的话(比如使用自己在ArrayList类上扩展的方法),最好使用List list = new LinkedList(); ,便于程序代码的重构. 这就是面向接口编程的好处。</p></blockquote><p><strong>解释：</strong> </p><blockquote><p>List有多个实现类，如LinkedList或者Vector等等，现在你用的是ArrayList，也许哪一天你需要换成其它的实现类呢？这时你只要改变这一行就行了：List list = new LinkedList();<br>其它使用了list地方的代码根本不需要改动。<br>假设你开始用 ArrayList alist = new ArrayList(), 这下你有的改了，特别是如果你使用了 ArrayList特有的方法和属性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称加密和非对称加密(DES and RSA)</title>
      <link href="/2019/06/28/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-DES-and-RSA/"/>
      <url>/2019/06/28/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-DES-and-RSA/</url>
      
        <content type="html"><![CDATA[<h3 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1.对称加密"></a>1.对称加密</h3><p><strong>对称加密算法</strong>是应用较早的加密算法，又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。这就要求加密和解密方事先都必须知道加密的密钥。</p><ul><li><p>数据加密过程：在对称加密算法中，数据发送方 将 明文 (原始数据) 和 加密密钥 一起经过特殊 加密处理，生成复杂的 加密密文 进行发送。</p></li><li><p>数据解密过程：数据接收方 收到密文后，若想读取原数据，则需要使用 加密使用的密钥 及相同算法的 逆算法 对加密的密文进行解密，才能使其恢复成 可读明文。</p></li></ul><h4 id="1-1-DES算法"><a href="#1-1-DES算法" class="headerlink" title="1.1  DES算法"></a>1.1  DES算法</h4><p><strong>DES 加密算法</strong>是一种分组密码，以 64 位为 分组对数据 加密，它的 密钥长度 是 56 位，加密解密 用 同一算法。</p><blockquote><p>DES 加密算法是对 密钥 进行保密，而 公开算法，包括加密和解密算法。这样，只有掌握了和发送方 相同密钥 的人才能解读由 DES加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 搜索密钥的编码。对于 56 位长度的 密钥 来说，如果用 穷举法 来进行搜索的话，其运算次数为 2 ^ 56 次。</p></blockquote><h4 id="1-2-3DES算法"><a href="#1-2-3DES算法" class="headerlink" title="1.2  3DES算法"></a>1.2  3DES算法</h4><p>是基于 DES 的 对称算法，对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。</p><h3 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2. 非对称加密"></a>2. 非对称加密</h3><p><strong>非对称加密算法</strong>，又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。</p><ul><li><p>如果使用 公钥 对数据 进行加密，只有用对应的 私钥 才能 进行解密。</p></li><li><p>如果使用 私钥 对数据 进行加密，只有用对应的 公钥 才能 进行解密。</p></li></ul><h4 id="2-1-RSA算法"><a href="#2-1-RSA算法" class="headerlink" title="2.1  RSA算法"></a>2.1  RSA算法</h4><p><strong>RSA 加密算法</strong>是目前最有影响力的 公钥加密算法，并且被普遍认为是目前 最优秀的公钥方案 之一。RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</p><blockquote><p>RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端面试网址汇总</title>
      <link href="/2019/06/22/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/22/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="cyc2018总结"><a href="#cyc2018总结" class="headerlink" title="cyc2018总结"></a>cyc2018总结</h3><p><a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/</a></p><h3 id="掘金总结"><a href="#掘金总结" class="headerlink" title="掘金总结"></a>掘金总结</h3><p><a href="https://juejin.im/post/5ba591386fb9a05cd31eb85f" target="_blank" rel="noopener">https://juejin.im/post/5ba591386fb9a05cd31eb85f</a></p><h3 id="JavaGuide"><a href="#JavaGuide" class="headerlink" title="JavaGuide"></a>JavaGuide</h3><p><a href="https://snailclimb.gitee.io/javaguide/#/?id=java" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/?id=java</a></p><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><p><a href="https://juejin.im/post/5ab1ed535188257b1c75171c" target="_blank" rel="noopener">https://juejin.im/post/5ab1ed535188257b1c75171c</a><br><a href="https://www.cnblogs.com/jingmoxukong/p/9408037.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingmoxukong/p/9408037.html</a></p><h3 id="spring-MVC"><a href="#spring-MVC" class="headerlink" title="spring MVC"></a>spring MVC</h3><p><a href="https://blog.csdn.net/weixin_42342702/article/details/93141533" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42342702/article/details/93141533</a><br><a href="https://blog.csdn.net/a745233700/article/details/80963758" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/80963758</a></p><h3 id="hinbernate"><a href="#hinbernate" class="headerlink" title="hinbernate"></a>hinbernate</h3><p><a href="https://blog.csdn.net/weixin_42342702/article/details/93364982" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42342702/article/details/93364982</a><br><a href="https://www.javazhiyin.com/18851.html" target="_blank" rel="noopener">https://www.javazhiyin.com/18851.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 工作原理</title>
      <link href="/2019/06/20/Spring-MVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/20/Spring-MVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-MVC概述："><a href="#1-Spring-MVC概述：" class="headerlink" title="1.Spring MVC概述："></a>1.Spring MVC概述：</h1><ul><li>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</li><li>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。<h4 id="他的两个核心是两个核心："><a href="#他的两个核心是两个核心：" class="headerlink" title="他的两个核心是两个核心："></a>他的两个核心是两个核心：</h4></li><li>处理器映射：选择使用哪个控制器来处理请求 </li><li>视图解析器：选择结果应该如何渲染<blockquote><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p></blockquote></li></ul><h1 id="2-SpringMVC运行原理"><a href="#2-SpringMVC运行原理" class="headerlink" title="2.SpringMVC运行原理"></a>2.SpringMVC运行原理</h1><p>   <img src="https://img-blog.csdnimg.cn/20190620232830756.png" alt="在这里插入图片描述"></p><ul><li>(1) Http请求：客户端请求提交到DispatcherServlet。 </li><li>(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li><li>(3) 调用处理器：DispatcherServlet将请求提交到Controller。 </li><li>(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li><li>(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li><li>(8) Http响应：视图负责将结果显示到客户端。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句技巧：查询存在一个表而不在另一个表中的数据记录</title>
      <link href="/2019/06/19/SQL%E8%AF%AD%E5%8F%A5%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%80%8C%E4%B8%8D%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/19/SQL%E8%AF%AD%E5%8F%A5%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%80%8C%E4%B8%8D%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一-仅适用单个字段"><a href="#方法一-仅适用单个字段" class="headerlink" title="方法一(仅适用单个字段)"></a>方法一(仅适用单个字段)</h2><p>使用 not in ,容易理解,效率低</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">select</span> A.ID <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.ID <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">from</span> B)<br></code></pre></td></tr></table></figure><h2 id="方法二（适用多个字段匹配）"><a href="#方法二（适用多个字段匹配）" class="headerlink" title="方法二（适用多个字段匹配）"></a>方法二（适用多个字段匹配）</h2><p>使用 left join…on… , B.ID isnull  表示左连接之后在B.ID 字段为 null的记录</p><figure class="hljs highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">select</span> A.ID <span class="hljs-keyword">from</span> A <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.ID=B.ID <span class="hljs-keyword">where</span> B.ID <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h2 id="方法三（适用多个字段匹配）"><a href="#方法三（适用多个字段匹配）" class="headerlink" title="方法三（适用多个字段匹配）"></a>方法三（适用多个字段匹配）</h2><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.ID = B.ID) = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="方法四（适用多个字段匹配）"><a href="#方法四（适用多个字段匹配）" class="headerlink" title="方法四（适用多个字段匹配）"></a>方法四（适用多个字段匹配）</h2><figure class="hljs highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> A.ID=B.ID)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hibernate关于FetchType.LAZY和FetchType.EAGER什么区别</title>
      <link href="/2019/06/17/hibernate%E5%85%B3%E4%BA%8EFetchType-LAZY%E5%92%8CFetchType-EAGER%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/06/17/hibernate%E5%85%B3%E4%BA%8EFetchType-LAZY%E5%92%8CFetchType-EAGER%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1、<strong>FetchType.LAZY：</strong>懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载。</p><p>2、<strong>FetchType.EAGER：</strong>急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载。</p><h3 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h3><ul><li>比方User类有两个属性，name跟address，就像百度知道，登录后用户名是需要显示出来的，此属性用到的几率极大，要马上到数据库查，用急加载；</li><li>而用户地址大多数情况下不需要显示出来，只有在查看用户资料是才需要显示，需要用了才查数据库，用懒加载就好了。所以，并不是一登录就把用户的所有资料都加载到对象中;</li><li>于是有了这两种加载模式。</li></ul><h2 id="A、实体对象的延迟加载"><a href="#A、实体对象的延迟加载" class="headerlink" title="A、实体对象的延迟加载 "></a>A、实体对象的延迟加载 </h2><p>如果想对实体对象使用延迟加载，必须要在实体的映射配置文件中进行相应的配置，如下所示：</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br>　<span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”com.neusoft.entity.User”</span> <span class="hljs-attr">table</span>=<span class="hljs-string">”user”</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">”true”</span>&gt;</span><br>    　……<br>　<span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一般是对整个实体对象进行设置是否是懒加载，而非单个属性。若该实体对象关联某个对象，如下面：</p><h2 id="关联的实体对象通常是懒加载"><a href="#关联的实体对象通常是懒加载" class="headerlink" title="关联的实体对象通常是懒加载"></a>关联的实体对象通常是懒加载</h2><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"t_company"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEntity</span>&lt;<span class="hljs-title">Long</span>&gt;<br></span>&#123;<br><span class="hljs-keyword">private</span> String companyName;<br><br><span class="hljs-keyword">private</span> List&lt;Flight&gt; flights = <span class="hljs-keyword">new</span> ArrayList&lt;Flight&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCompanyName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> companyName;<br>&#125;<br><br><span class="hljs-meta">@OneToMany</span>(cascade=CascadeType.ALL,mappedBy=<span class="hljs-string">"company"</span>,fetch=FetchType.LAZY)<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Flight&gt; <span class="hljs-title">getFlights</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> flights;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlights</span><span class="hljs-params">(List&lt;Flight&gt; flights)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.flights = flights;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCompanyName</span><span class="hljs-params">(String companyName)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.companyName = companyName;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>mappedBy=”company”:设置mappedBy表示声明自己不是一对多的关系维护端，由对方来维护，是在一的一方进行声明的。mappedBy的值应该为一的一方的表名。</p></li><li><p>fetch=FetchType.LAZY:关联的实体对象是懒加载</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类class或者list&lt;class&gt;转化为的Json</title>
      <link href="/2019/06/16/Java-%E7%B1%BBclass%E6%88%96%E8%80%85list-class-%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9A%84Json/"/>
      <url>/2019/06/16/Java-%E7%B1%BBclass%E6%88%96%E8%80%85list-class-%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9A%84Json/</url>
      
        <content type="html"><![CDATA[<p>Java的Json解析包FastJson使用<br>阿里巴巴FastJson是一个Json处理工具包，包括“序列化”和“反序列化”两部分，它具备如下特征：<br>速度最快，测试表明，fastjson具有极快的性能，超越任其他的Java Json parser。包括自称最快的JackJson；<br>功能强大，完全支持Java Bean、集合、Map、日期、Enum，支持范型，支持自省；无依赖，能够直接运行在Java SE 5.0以上版本；支持Android；开源 (Apache 2.0)</p><p>源码地址：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a><br><strong>Maven</strong></p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.54<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Fastjson API入口类是com.alibaba.fastjson.JSON，常用的序列化操作都可以在JSON类上的静态方法直接完成。</p><figure class="hljs highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">*<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> toJSONString(<span class="hljs-keyword">Object</span> object); <span class="hljs-comment">// 将JavaBean序列化为JSON文本 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> toJSONString(<span class="hljs-keyword">Object</span> object, <span class="hljs-built_in">boolean</span> prettyFormat); <span class="hljs-comment">// 将JavaBean序列化为带格式的JSON文本 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span> toJSON(<span class="hljs-keyword">Object</span> javaObject); 将JavaBean转换为<span class="hljs-keyword">JSONObject</span>或者<span class="hljs-keyword">JSONArray</span>。<br></code></pre></td></tr></table></figure><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> bean;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassToJson</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassToJson</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public static <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        ClassToJson classTJ=<span class="hljs-keyword">new</span> ClassToJson(<span class="hljs-number">15</span>,<span class="hljs-string">"刘诗诗"</span>);<br>        List&lt;ClassToJson&gt; <span class="hljs-built_in">list</span>=<span class="hljs-keyword">new</span> ArrayList&lt;ClassToJson&gt;();<br>        <span class="hljs-built_in">list</span>.add(classTJ);<br><br>        <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> ClassToJson(<span class="hljs-number">18</span>,<span class="hljs-string">"Stephen"</span>));<br>        <span class="hljs-comment">//将集合或者对象序例化成JSON</span><br>        <span class="hljs-built_in">JSON</span> json= (<span class="hljs-built_in">JSON</span>) <span class="hljs-built_in">JSON</span>.toJSON(<span class="hljs-built_in">list</span>);<br>        System.out.println(json);<br>        System.out.println(<span class="hljs-built_in">JSON</span>.toJSON(<span class="hljs-built_in">list</span>));<br>        System.out.println(<span class="hljs-built_in">JSON</span>.toJSON(classTJ));<br>        System.out.println(<span class="hljs-built_in">JSON</span>.toJSONString(<span class="hljs-built_in">list</span>));<br>        System.out.println(<span class="hljs-built_in">JSON</span>.toJSONString(classTJ));<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：使用Java实现两个矩阵相乘</title>
      <link href="/2019/06/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/"/>
      <url>/2019/06/16/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<figure class="hljs highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">juzhengxiangcheng</span> </span>&#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] matrix(<span class="hljs-keyword">int</span> a[][], <span class="hljs-keyword">int</span> b[][]) &#123;<br>        <span class="hljs-comment">//当a的列数与矩阵b的行数不相等时，不能进行点乘，返回null</span><br>        <span class="hljs-keyword">if</span> (a.length != b[<span class="hljs-number">0</span>].length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//c矩阵的行数y，与列数x</span><br>       <span class="hljs-keyword">int</span> N=a.length;<br>        <span class="hljs-keyword">int</span> c[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>                <span class="hljs-comment">//c矩阵的第i行第j列所对应的数值，等于a矩阵的第i行分别乘以b矩阵的第j列之和</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; N; k++)<br>                    c[i][j] += a[i][k] * b[k][j];<br>        <span class="hljs-keyword">return</span> c;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo+Github搭建个人博客</title>
      <link href="/2019/06/16/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/06/16/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>一直想要拥有自己的一个博客，CSDN，那些又觉得不够个性化</p><p> <strong>Github搭建博客的优点：</strong></p><blockquote><p>1、不需要域名和服务器<br>2、访问自己博客的时候没有广告<br>3、可以自己修改样式，能根据自己的需求加功能。</p></blockquote><p>首先来一篇预览的博客，让大家看看效果：这是我自己用Github搭建的：<a href="https://zhengyongrong.github.io/" target="_blank" rel="noopener">https://zhengyongrong.github.io/</a></p><h2 id="以下操作基于Windows环境"><a href="#以下操作基于Windows环境" class="headerlink" title="以下操作基于Windows环境"></a><strong>以下操作基于Windows环境</strong></h2><p>首先博客搭建的环境﻿</p><blockquote><p>node.js 因为整个博客框架是基于node.js的，所以必须安装node.js环境，安装过程中一路Next即可。<br>Git客户端 Git用来将hexo的相关文件部署到Github上去，安装过程一路Next。</p></blockquote><h2 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h2><blockquote><p>环境准备好以后，我们便可以安装hexo的博客框架。<br>在桌面鼠标右击，选择 Git Bash Here,</p></blockquote><p>然后就会打开Git的命令窗口，在命令窗口输入安装命令后，然后回车</p><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>然后在指定的盘新建一个名为“ hexo ”的文件夹，然后以下的命令都在新建的hexo文件下进行</p><blockquote><p>在这个新建的文件夹内鼠标右键，同样选择Git Bash Here,输入初始化命令，然后回车;<br>等命令执行完，就会看到生成了一系列的文件；</p></blockquote><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">hexo init</span><br></code></pre></td></tr></table></figure><p>安装相关的依赖包，输入下面的命令，回车</p><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>接着在hexo文件夹下面继续执行以下命令</p><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">hexo g<br>hexo s</span><br></code></pre></td></tr></table></figure><p>命令执行完后浏览器访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ,就会看到hexo的初始界面，是不是有着一丝丝的成就感？但是，这个界面还是在本地，别人并不能看到，想要别人看到，我们就必须将这些文件部署到Github上去。</p><h2 id="创建Github号"><a href="#创建Github号" class="headerlink" title="创建Github号"></a>创建Github号</h2><blockquote><p>首先我们需要到Github官网创建一个账号，创建链接：Github</p></blockquote><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><blockquote><p>创建完账号后我们新建一个Repository</p></blockquote><p><strong>这里要注意仓库的名字，必须是自己的Github账户的用户名.github.io</strong></p><h2 id="部署文件到Github"><a href="#部署文件到Github" class="headerlink" title="部署文件到Github"></a>部署文件到Github</h2><blockquote><p>接下来就是部署文件到Github了。<br>用Nodepad++打开hexo文件夹下面的_config.yml文件，该文件的最下面找到关键字deploy,然后修改成下面这样，用我自己的做案例</p></blockquote><figure class="hljs highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> <span class="hljs-params">&lt;https://github.com/Chakid/Chakid.github.io.git&gt;</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>这里拥有两个注意点：</p><blockquote><p>1、每个冒号后面都有一个空格，修改的时候别忘了；<br>2、注意修改的对应点要是自己的Github的账户名，别修改错了。<br>修改完保存<br>但是这样还不能连接到 github ，我们还需要配置SSH，找到路径C:\Users\leeyom.ssh，如果已经存在SSH Keys ，直接删除.ssh 文件夹下的所有的文件，如下图。</p></blockquote><p>然后继续在hexo文件夹下面输入下面的指令</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">ssh-keygen</span> <span class="hljs-selector-tag">-t</span> <span class="hljs-selector-tag">rsa</span> <span class="hljs-selector-tag">-C</span> "1547658639@<span class="hljs-keyword">qq</span>.<span class="hljs-keyword">com</span>"<br></code></pre></td></tr></table></figure><p>然后再回车三次，等命令执行完，再输入以下指令</p><figure class="hljs highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">eval `ssh-agent -s`<br>ssh-add<br></code></pre></td></tr></table></figure><p>然后输入指令拷贝Key</p><figure class="hljs highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">clip &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><p>然后进入自己刚注册的Github</p><p>接下来测试ssh是否配好了，输入下面的指令，会提示你输入yes/no你输入yes就行，这样ssh就配好了，接下来我们就可以将项目部署到Github上面了。</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">-T</span> <span class="hljs-selector-tag">git</span>@<span class="hljs-keyword">github</span>.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>然后执行以下命令将项目部署到Github上面</p><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">hexo g<br>hexo d</span><br></code></pre></td></tr></table></figure><p>但是输入hexo d可能会报ERROR Deployer not fount： git错误，这是因为没有安装hexo-deployer-git这个模块，导致Git不能识别该命令，输入下面指令安装该模块即可。</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>安装该模块的时间由网速决定，因为Github毕竟是国外的网站，并不是很稳定，所以请读者耐心等待。有事可能会因为断网等导致该模块安装失败，安装失败时还请读者多试两边。等模块安装完再次执行</p><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>这是就会有弹出框，输入自己之前注册的github账号进行登录即可，然后浏览器输入Chakid.github.io进行访问即可，（将Chakid改成自己之前注册的Github的用户名即可） 这时就会发现可以访问自己之前在本地预览的页面了。</p><h2 id="此时是不是有着一丝丝的成就感，终于有了属于自己的博客。"><a href="#此时是不是有着一丝丝的成就感，终于有了属于自己的博客。" class="headerlink" title="此时是不是有着一丝丝的成就感，终于有了属于自己的博客。"></a>此时是不是有着一丝丝的成就感，终于有了属于自己的博客。</h2><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a><strong>附录：</strong></h2><p>常用指令</p><figure class="hljs highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo g #完整命令为hexo <span class="hljs-keyword">generate</span>,用于生成静态文件<br>hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览<br>hexo d #完整命令为hexo deploy,用于将本地文件发布到github上<br>hexo n #完整命令为hexo <span class="hljs-keyword">new</span>,用于新建一篇文章<br></code></pre></td></tr></table></figure><p>转载自<a href="https://www.chakid.com/" target="_blank" rel="noopener">https://www.chakid.com/</a> ，感谢该作者。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：最大公约数</title>
      <link href="/2019/06/01/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2019/06/01/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>#欧几里得算法：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。</p><p>问题：求p,q的最大公约数：</p><blockquote><p>（1）若q=0;p为最大公约数；<br>（2）否则，p除以q的余数r，p和q的最大公约数为q与r的最大公约数</p></blockquote><figure class="hljs highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GongYueShu</span> &#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gongyueshu</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y</span>)</span> &#123;<br><br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>) <br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">int</span> r=x%y;<br><span class="hljs-keyword">return</span> gongyueshu(y, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String arg[]</span>)</span> &#123;<br><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"公约数："</span>+gongyueshu(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Maven的C3P0连接池使用教程</title>
      <link href="/2019/03/26/%E5%9F%BA%E4%BA%8EMaven%E7%9A%84C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/03/26/%E5%9F%BA%E4%BA%8EMaven%E7%9A%84C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用C3P0"><a href="#为什么使用C3P0" class="headerlink" title="为什么使用C3P0:"></a>为什么使用C3P0:</h2><p>一般我们在项目中操作数据库时，都是每次需要操作数据库就建立一个连接，操作完成后释放连接。因为jdbc没有保持连接的能力，一旦超过一定时间没有使用（大约几百毫秒），连接就会被自动释放掉。而每次新建连接都需要140毫秒左右的时间，所以耗费时间比较多。若使用C3P0连接池来池化连接，随时取用，则平均每次取用只需要10-20毫秒。这在高并发随机访问数据库的时候对效率的提升有很大帮助。<br>     C3P0连接池会根据你的配置来初始化N个数据库连接，空闲T时间后连接过期又会自动新建K个连接使得连接池总有空闲的数据库连接等待被取用。我们只需通过dataSourse.getConnection()即可从线程池中取用一个已经连接好的空闲连接，执行数据库操作。然后“断开”（放回）这个连接，把这个连接的使用权放回连接池。真正的数据库连接的创建与释放是由C3P0在后台自动完成的，我们花的只是取用与释放占用权的时间。全程耗时10+毫秒，比原来提高了几十倍。</p><p><strong>C3P0连接池使用教程</strong><br>Maven项目导入jar包依赖：</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="在src目录下新建一个名叫-c3p0-config-xml-的文件，注意，必须是这个文件名。"><a href="#在src目录下新建一个名叫-c3p0-config-xml-的文件，注意，必须是这个文件名。" class="headerlink" title="在src目录下新建一个名叫  c3p0-config.xml  的文件，注意，必须是这个文件名。"></a>在src目录下新建一个名叫  c3p0-config.xml  的文件，注意，必须是这个文件名。</h2><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">c3p0-config</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--默认配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">default-config</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"initialPoolSize"</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxIdleTime"</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxPoolSize"</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"minPoolSize"</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxStatements"</span>&gt;</span>200<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">default-config</span>&gt;</span>  <br>  <br>   <span class="hljs-comment">&lt;!--配置连接池mysql--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">named-config</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mysql"</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/CoupleSpace<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"initialPoolSize"</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxIdleTime"</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxPoolSize"</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"minPoolSize"</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxStatements"</span>&gt;</span>200<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">named-config</span>&gt;</span>  <br>    <br>    <span class="hljs-comment">&lt;!--配置连接池2--&gt;</span><br>    ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">c3p0-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>如何使用</strong></p><figure class="hljs highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3p0Utils</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> org.apache.log4j.Logger logger=org.apache.log4j.Logger.getLogger(C3p0Utils.class.getName());<br>    <br>    <span class="hljs-comment">//通过标识名来创建相应连接池</span><br>    <span class="hljs-keyword">static</span> ComboPooledDataSource dataSource=<span class="hljs-keyword">new</span> ComboPooledDataSource(<span class="hljs-string">"mysql"</span>);<br>    <span class="hljs-comment">//从连接池中取用一个连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> dataSource.<span class="hljs-title">getConnection</span><span class="hljs-params">()</span></span>;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">"Exception in C3p0Utils!"</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyError(<span class="hljs-string">"数据库连接出错!"</span>, e);            <br>        &#125;<br>    &#125;    <br>    <span class="hljs-comment">//释放连接回连接池</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Connection conn,PreparedStatement pst,ResultSet rs)</span></span>&#123;  <br>            <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>)&#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    rs.close();  <br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;  <br>                    logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">"Exception in C3p0Utils!"</span>, e);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyError(<span class="hljs-string">"数据库连接关闭出错!"</span>, e);            <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(pst!=<span class="hljs-keyword">null</span>)&#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    pst.close();  <br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;  <br>                    logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">"Exception in C3p0Utils!"</span>, e);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyError(<span class="hljs-string">"数据库连接关闭出错!"</span>, e);    <br>                &#125;  <br>            &#125;  <br>      <br>            <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)&#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br>                    conn.close();  <br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;  <br>                    logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">"Exception in C3p0Utils!"</span>, e);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyError(<span class="hljs-string">"数据库连接关闭出错!"</span>, e);    <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql,Oracle,SQL server 分页查询</title>
      <link href="/2018/12/16/Mysql-Oracle-SQL-server-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
      <url>/2018/12/16/Mysql-Oracle-SQL-server-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql分页查询"><a href="#Mysql分页查询" class="headerlink" title="Mysql分页查询"></a>Mysql分页查询</h2><p><strong>PageNo 为当前页数，PageSize为每页的条数</strong></p><figure class="hljs highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">SELECT</span>    *<br><span class="hljs-keyword">FROM</span>  TABLE_NAME<br><span class="hljs-keyword">LIMIT</span> (PageNo - <span class="hljs-number">1</span>) * PageSize,PageSize;<br></code></pre></td></tr></table></figure><h2 id="Oracel的分页查询："><a href="#Oracel的分页查询：" class="headerlink" title="Oracel的分页查询："></a>Oracel的分页查询：</h2><p><strong>其中最内层的查询SELECT * FROM TABLE_NAME表示不进行翻页的原始查询语句。ROWNUM &lt;= 40和RN &gt;= 21控制分页查询的每页的范围。</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span>  <br>(  <br><span class="hljs-keyword">SELECT</span> A.*, <span class="hljs-keyword">ROWNUM</span> RN  <br><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> TABLE_NAME) A  <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">40</span>  <br>)  <br><span class="hljs-keyword">WHERE</span> RN &gt;= <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h2 id="SQL-Server分页查询"><a href="#SQL-Server分页查询" class="headerlink" title="SQL Server分页查询"></a>SQL Server分页查询</h2><p><strong>假设每页的条数是10，现在要拿出第5页的内容，查询语句如下：</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">select</span> top <span class="hljs-number">10</span> *<br><span class="hljs-keyword">from</span> TABLE_NAME<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span><br>(<br> 条数是这么计算出来的：<span class="hljs-number">10</span>*(<span class="hljs-number">5</span><span class="hljs-number">-1</span>)=<span class="hljs-number">40</span><br> <span class="hljs-keyword">select</span> top <span class="hljs-number">40</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span><br>)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/08/16/hello-world/"/>
      <url>/2017/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><strong>教育经历</strong></p><blockquote><p>东莞理工学院 - 软件工程专业（教育部“卓越工程师计划“） 本科 网络空间安全学院 2016年9月 - 2020年6月<br>GPA：3.56 / 5.0（专业前5%）</p></blockquote><p><strong>荣誉证书</strong></p><blockquote><p>2016-2017学年东莞理工学院一等奖学金<br>2016-2017学年校级优秀大学生称号<br>2017-2018学年校级优秀学生干部<br>2017-2018学年四六级证书<br>2018-2019学年全国大学生创新创业实践项目（省级）<br>2018-2019学年第十届蓝桥杯全国软件和信息技术专业人才大赛—个人赛省赛（软件类）三等奖       </p></blockquote><p><strong>项目经历</strong></p><blockquote><p>大学生通过填写的信息，智能匹配CP。CP可以参加交友平台发布的线上线下活动，增进彼此的感情， 也可以到社区发布心情，平台会一直跟进CP的亲密度变化。</p></blockquote><p><strong>项目职责：</strong></p><blockquote><p>1.参与项目的需求分析、可行性分析，完成详细设计；<br>2.负责数据库的设计及SQL的编写；<br>3.作为后端开发人员，负责后台与数据库的连接，后端与前端数据的交互，及后端大部分功能的实现；<br>4.在Linux下进行程序部署，负责数据库和服务器的日常维护和管理。</p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
